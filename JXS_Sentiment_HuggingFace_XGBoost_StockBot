#FinBERT Hugging Face Sentiment Analysis
#Pretrained NLP (Natual Language Processing) analyzes sentiment, built by Prosus AI
#Need the model than analyzes Financial Data, rather than general, thus using FinBERT 
#Need to use Transformers to feed into Pipeline
#Will be scraping news data from yahoo Finance RSS Feed
#Feedpasers is only necessary if we want to use an RSS Feed (Really Simple Syndication is a web feed that allows users and applications to receive updates from websites in a standardized, computer-readable format)
#The stock data only includes trading days, but the news articles can be published on any day, including weekends and holidays. When we reindex the sentiment data to the stock's date range (which skips non-trading days), any news from non-trading days get their dates adjusted to the nearest trading day or dropped, leading to zeros.


#Virutual Environment: 3.10.16 ('.conda':conda)
#pip install streamlit, feedparser, transformers, tf-keras, pandas, yfinance, datetime, matplotlib, pytz, pandas, dateutil, numpy, scikit-learn, xgboost
import streamlit as st
import feedparser
from transformers import pipeline
import pandas as pd
import yfinance as yf                    #Need to run this in terminal: pip install --upgrade yfinance
from datetime import datetime
import matplotlib.pyplot as plt
from dateutil import parser
import pytz
from pandas.tseries.offsets import BDay  #For business day calculations
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import xgboost as xgb


#Initialize Hugging Face FinBERT Data pipeline
pipe = pipeline(task="text-classification", model="ProsusAI/finbert")

#For timezone conversion
def convert_to_utc_naive(dt):
    """Convert any datetime object to UTC-naive format"""
    if isinstance(dt, pd.Timestamp):
        dt = dt.to_pydatetime()
    if dt.tzinfo is not None:
        return dt.astimezone(pytz.utc).replace(tzinfo=None)
    return dt

#Custom CSS Streamlit Colour Scheme
st.markdown("""
<style>
.stApp {
    background-color: #000000;
    color: #FFFFFF;
}
h1, h2, h3, h4, h5, h6 {
    color: #800080;
}
.stButton>button {
    background-color: #800080;
    color: #FFFFFF;
    border-radius: 5px;
    border: 1px solid #800080;
}
.stTextInput>div>div>input {
    background-color: #000000;
    color: #FFFFFF;
    border: 1px solid #800080;
}
.stSlider>div>div>div>div {
    background-color: #800080;
}
.stDataFrame {
    background-color: #1A1A1A;
}
.st-ae {
    background-color: #1A1A1A;
}
</style>
""", unsafe_allow_html=True)

#Streamlit Layout
st.sidebar.header("Input Parameters")
ticker = st.sidebar.text_input("Stock Ticker", "XYZ")
keyword = st.sidebar.text_input("Company Keyword", "Block")
forecast_days = st.sidebar.slider("Days to Forecast", 1, 50, 7)
run_button = st.sidebar.button("Run Analysis")

#Debugging Switch
debug_mode = st.sidebar.checkbox("Show Debugging Info")

st.title("Comprehensive Financial Analysis")
st.subheader(f"Analysis Report for {ticker}")

#Stock Data Analysis Section
try:
    st.write("## Complete Stock Data Analysis")
    
    #Creating dynamic date range with timezone awareness
    now_utc = datetime.now(pytz.utc)
    start_date = datetime(1997, 1, 1, tzinfo=pytz.utc)  #Set start date as January 1, 1997
    end_date = now_utc + pd.DateOffset(days=1)          #Including today's potential articles

    # Fetch the stock data with timezone-aware dates
    df = yf.download(ticker, start=start_date, end=end_date)

    if not df.empty:
        # --- Add This Critical Line ---
        df['Daily Return %'] = df['Close'].pct_change() * 100
        
        # Create trading date reference
        trading_dates = df.index.normalize().unique()
        
        # --- Sentiment Processing with Trading Date Alignment ---
        sentiment_data = []
        rss_url = f'https://feeds.finance.yahoo.com/rss/2.0/headline?s={ticker}&region=US&lang=en-US'
        feed = feedparser.parse(rss_url)
        
        if feed.entries:
            if debug_mode:
                st.sidebar.subheader("Raw Feed Debug")
                st.sidebar.write(f"Total articles: {len(feed.entries)}")
                st.sidebar.write("First article:", feed.entries[0])

            for entry in feed.entries:
                try:
                    # Check keyword match
                    if keyword.lower() not in entry.summary.lower():
                        continue

                    # Parse and normalize date
                    pub_date = entry.get('published')
                    if not pub_date:
                        continue
                                        # Parse and normalize date with timezone awareness
                    parsed_date = parser.parse(pub_date)
                    if not parsed_date.tzinfo:
                        parsed_date = parsed_date.replace(tzinfo=pytz.utc)
                    else:
                        parsed_date = parsed_date.astimezone(pytz.utc)
                        
                    # Convert to naive datetime in UTC for comparison
                    article_date = parsed_date.replace(tzinfo=None)
                    
                    # Find matching trading day (allow same-day if market is open)
                    # Get all possible trading dates up to now
                    possible_dates = df.loc[:now_utc.replace(tzinfo=None)].index
                    
                    # Find the nearest trading day (including same day if market open)
                    next_trading_day = min(
                        possible_dates[possible_dates >= article_date],
                        default=None
                    )
                    
                    # Create trading date reference with timezone-naive UTC dates
                    trading_dates = df.index.tz_localize(None).unique()
                    if next_trading_day is None:
                        # If article is after market close, use next trading day
                        next_trading_day = pd.to_datetime(article_date) + BDay(1)
                        if next_trading_day not in trading_dates:
                            continue

                    # Get sentiment
                    sentiment = pipe(entry.summary)[0]
                    score = sentiment['score']
                    if sentiment['label'] == 'negative':
                        score *= -1

                    sentiment_data.append({
                        'Date': next_trading_day,
                        'Score': score,
                        'Title': entry.title
                    })

                except Exception as e:
                    if debug_mode:
                        st.sidebar.error(f"Article error: {str(e)}")

        # Create and merge sentiment data
        if sentiment_data:
            sentiment_df = pd.DataFrame(sentiment_data)
            sentiment_df = sentiment_df.groupby('Date')['Score'].mean().to_frame()
            
            # Merge with all trading dates
            sentiment_full = pd.DataFrame(index=trading_dates)
            sentiment_full = sentiment_full.join(sentiment_df).fillna(0)
            
            if debug_mode:
                st.sidebar.subheader("Sentiment Debug")
                st.sidebar.write("Raw sentiment data:", sentiment_data[:3])
                st.sidebar.write("Processed sentiment:", sentiment_df.head())
        else:
            sentiment_full = pd.DataFrame(index=trading_dates, data={'Score': 0.0})

        # --- COMBINED TABLE SECTION ---
        st.write("### Combined Sentiment & Returns Analysis")
        
        # Create combined dataframe
        combined_df = pd.DataFrame({
            'Date': df.index,
            'Sentiment Score': sentiment_full['Score'],
            'Daily Return %': df['Daily Return %']
        }).set_index('Date')
        
        # Style formatting
        combined_style = combined_df.style.format({
            'Sentiment Score': '{:.2f}',
            'Daily Return %': '{:.2f}%'
        }, na_rep="-")
        
        # Color conditional formatting
        combined_style = combined_style.applymap(
            lambda x: 'color: green' if isinstance(x, float) and x > 0 else 'color: red' if isinstance(x, float) and x < 0 else '',
            subset=['Sentiment Score', 'Daily Return %']
        )
        
        st.dataframe(
            combined_style,
            height=400,
            use_container_width=True
        )

        # Price moving averages
        df['Close_MA_20'] = df['Close'].rolling(window=20).mean()
        df['Close_MA_50'] = df['Close'].rolling(window=50).mean()
        df['Close_MA_100'] = df['Close'].rolling(window=100).mean()
        
        # Price Returns moving averages
        df['Return_MA_20'] = df['Daily Return %'].rolling(window=20).mean()
        df['Return_MA_50'] = df['Daily Return %'].rolling(window=50).mean()
        df['Return_MA_100'] = df['Daily Return %'].rolling(window=100).mean()

        # Display stock analysis
        st.success("âœ… Successfully retrieved historical stock data")
